/*
* This file is part of the Head Tracker distribution (https://github.com/dlktdr/headtracker)
* Copyright (c) 2022 Cliff Blackburn
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**********************************************
 *
 *  !!! THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY !!!
 *
 *  Modify /utils/settings.csv and execute settings.py to generate the GUI and FW headers
 *
 ***********************************************/

#pragma once

#include "arduinojsonwrp.h"

class TrackerSettings {
public:
  static constexpr float FLOAT_MIN = -1000000;
  static constexpr float FLOAT_MAX = 1000000;
  static constexpr uint16_t MIN_PWM = 988;
  static constexpr uint16_t MAX_PWM = 2012;
  static constexpr uint16_t DEF_MIN_PWM = 1050;
  static constexpr uint16_t DEF_MAX_PWM = 1950;
  static constexpr uint16_t PPM_CENTER = 1500;
  static constexpr float MIN_GAIN = 0.01;
  static constexpr float MAX_GAIN = 35;
  static constexpr uint8_t BT_CHANNELS = 8;
  static constexpr uint8_t MAX_CHANNELS = 16;

  TrackerSettings() {
    for(int i = 0; i < 9; i++) {
      MagSiOff[i] = 0;
    }
  }

  // Roll Minimum
  inline uint16_t getRll_Min() {return rll_min;}
  bool setRll_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_min = val;
      return true;
    }
    return false;
  }

  // Roll Maximum
  inline uint16_t getRll_Max() {return rll_max;}
  bool setRll_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_max = val;
      return true;
    }
    return false;
  }

  // Roll Center
  inline uint16_t getRll_Cnt() {return rll_cnt;}
  bool setRll_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_cnt = val;
      return true;
    }
    return false;
  }

  // Roll Gain
  inline uint16_t getRll_Gain() {return rll_gain;}
  bool setRll_Gain(uint16_t val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      rll_gain = val;
      return true;
    }
    return false;
  }

  // Tilt Minimum
  inline uint16_t getTlt_Min() {return tlt_min;}
  bool setTlt_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_min = val;
      return true;
    }
    return false;
  }

  // Tilt Maximum
  inline uint16_t getTlt_Max() {return tlt_max;}
  bool setTlt_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_max = val;
      return true;
    }
    return false;
  }

  // Tilt Center
  inline uint16_t getTlt_Cnt() {return tlt_cnt;}
  bool setTlt_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_cnt = val;
      return true;
    }
    return false;
  }

  // Tilt Gain
  inline uint16_t getTlt_Gain() {return tlt_gain;}
  bool setTlt_Gain(uint16_t val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      tlt_gain = val;
      return true;
    }
    return false;
  }

  // Pan Minimum
  inline uint16_t getPan_Min() {return pan_min;}
  bool setPan_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_min = val;
      return true;
    }
    return false;
  }

  // Pan Maximum
  inline uint16_t getPan_Max() {return pan_max;}
  bool setPan_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_max = val;
      return true;
    }
    return false;
  }

  // Pan Center
  inline uint16_t getPan_Cnt() {return pan_cnt;}
  bool setPan_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_cnt = val;
      return true;
    }
    return false;
  }

  // Pan Gain
  inline uint16_t getPan_Gain() {return pan_gain;}
  bool setPan_Gain(uint16_t val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      pan_gain = val;
      return true;
    }
    return false;
  }

  // Tilt Output Channel
  inline uint8_t getTltCh() {return tltch;}
  bool setTltCh(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      tltch = val;
      return true;
    }
    return false;
  }

  // Roll Output Channel
  inline uint8_t getRllCh() {return rllch;}
  bool setRllCh(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      rllch = val;
      return true;
    }
    return false;
  }

  // Pan Output Channel
  inline uint8_t getPanCh() {return panch;}
  bool setPanCh(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      panch = val;
      return true;
    }
    return false;
  }

  // Alert Output Channel
  inline uint8_t getAlertCh() {return alertch;}
  bool setAlertCh(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      alertch = val;
      return true;
    }
    return false;
  }

  // PWM 0 Channel
  inline uint8_t getPwm0() {return pwm0;}
  bool setPwm0(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      pwm0 = val;
      return true;
    }
    return false;
  }

  // PWM 1 Channel
  inline uint8_t getPwm1() {return pwm1;}
  bool setPwm1(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      pwm1 = val;
      return true;
    }
    return false;
  }

  // PWM 2 Channel
  inline uint8_t getPwm2() {return pwm2;}
  bool setPwm2(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      pwm2 = val;
      return true;
    }
    return false;
  }

  // PWM 3 Channel
  inline uint8_t getPwm3() {return pwm3;}
  bool setPwm3(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      pwm3 = val;
      return true;
    }
    return false;
  }

  // Analog 0 Channel
  inline uint8_t getAn0Ch() {return an0ch;}
  bool setAn0Ch(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      an0ch = val;
      return true;
    }
    return false;
  }

  // Analog 1 Channel
  inline uint8_t getAn1Ch() {return an1ch;}
  bool setAn1Ch(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      an1ch = val;
      return true;
    }
    return false;
  }

  // Analog 2 Channel
  inline uint8_t getAn2Ch() {return an2ch;}
  bool setAn2Ch(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      an2ch = val;
      return true;
    }
    return false;
  }

  // Analog 3 Channel
  inline uint8_t getAn3Ch() {return an3ch;}
  bool setAn3Ch(uint8_t val=0) {
    if(val >= 0 && val <= MAX_CHANNELS) {
      an3ch = val;
      return true;
    }
    return false;
  }

  // Servo Reverse (BitMask)
  inline uint8_t getServoRev() {return servorev;}
  bool setServoRev(uint8_t val=0) {
    if(val >= 0 && val <= 7) {
      servorev = val;
      return true;
    }
    return false;
  }

  // Magnetometer X Calibration Offset
  inline float getMagXOff() {return magxoff;}
  bool setMagXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magxoff = val;
      return true;
    }
    return false;
  }

  // Magnetometer Y Calibration Offset
  inline float getMagYOff() {return magyoff;}
  bool setMagYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magyoff = val;
      return true;
    }
    return false;
  }

  // Magnetometer Z Calibration Offset
  inline float getMagZOff() {return magzoff;}
  bool setMagZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magzoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer X Calibration Offset
  inline float getAccXOff() {return accxoff;}
  bool setAccXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      accxoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer Y Calibration Offset
  inline float getAccYOff() {return accyoff;}
  bool setAccYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      accyoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer Z Calibration Offset
  inline float getAccZOff() {return acczoff;}
  bool setAccZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      acczoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer X Calibration Offset
  inline float getGyrXOff() {return gyrxoff;}
  bool setGyrXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyrxoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer Y Calibration Offset
  inline float getGyrYOff() {return gyryoff;}
  bool setGyrYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyryoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer Z Calibration Offset
  inline float getGyrZOff() {return gyrzoff;}
  bool setGyrZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyrzoff = val;
      return true;
    }
    return false;
  }

  // Button Pin
  inline int8_t getButtonPin() {return buttonpin;}
  bool setButtonPin(int8_t val=-1) {
    if(val >= 64 && val <= -1) {
      buttonpin = val;
      return true;
    }
    return false;
  }

  // PPM Output Pin
  inline int8_t getPpmOutPin() {return ppmoutpin;}
  bool setPpmOutPin(int8_t val=-1) {
    if(val >= 64 && val <= -1) {
      ppmoutpin = val;
      return true;
    }
    return false;
  }

  // PPM Input Pin
  inline int8_t getPpmInPin() {return ppminpin;}
  bool setPpmInPin(int8_t val=-1) {
    if(val >= 64 && val <= -1) {
      ppminpin = val;
      return true;
    }
    return false;
  }

  // UART Receive Pin
  inline int8_t getUartRxPin() {return uartrxpin;}
  bool setUartRxPin(int8_t val=-1) {
    if(val >= 64 && val <= -1) {
      uartrxpin = val;
      return true;
    }
    return false;
  }

  // UART Transmit Pin
  inline int8_t getUartTxPin() {return uarttxpin;}
  bool setUartTxPin(int8_t val=-1) {
    if(val >= 64 && val <= -1) {
      uarttxpin = val;
      return true;
    }
    return false;
  }

  // SBUS Transmit Freqency
  inline uint8_t getSbRate() {return sbrate;}
  bool setSbRate(uint8_t val=30) {
    if(val >= 150 && val <= 80) {
      sbrate = val;
      return true;
    }
    return false;
  }

  // UART Receieve Inverted
  inline bool getUartRxInv() {return uartrxinv;}
  bool setUartRxInv(bool val=TRUE) {
    if(val >= 0 && val <= 1) {
      uartrxinv = val;
      return true;
    }
    return false;
  }

  // UART Transmit Inverted
  inline bool getUartTxInv() {return uarttxinv;}
  bool setUartTxInv(bool val=TRUE) {
    if(val >= 0 && val <= 1) {
      uarttxinv = val;
      return true;
    }
    return false;
  }

  // Magnetometer Soft Iron Offset Matrix
  void getMagSiOff(float dest[9]) {memcpy(dest, magsioff, sizeof(float) * 9);}
  bool setMagSiOff(const float val[9]) {
    for(int i=0; i < 9; i++) {
      if(magsioff[i] >= FLOAT_MIN && magsioff[i] <= FLOAT_MAX) {
        magsioff[i] = val[i];
      }
    }
  }

  void setJSONSettings(DynamicJsonDocument &json) {
    json["rll_min"] = rll_min;
    json["rll_max"] = rll_max;
    json["rll_cnt"] = rll_cnt;
    json["rll_gain"] = rll_gain;
    json["tlt_min"] = tlt_min;
    json["tlt_max"] = tlt_max;
    json["tlt_cnt"] = tlt_cnt;
    json["tlt_gain"] = tlt_gain;
    json["pan_min"] = pan_min;
    json["pan_max"] = pan_max;
    json["pan_cnt"] = pan_cnt;
    json["pan_gain"] = pan_gain;
    json["tltch"] = tltch;
    json["rllch"] = rllch;
    json["panch"] = panch;
    json["alertch"] = alertch;
    json["pwm0"] = pwm0;
    json["pwm1"] = pwm1;
    json["pwm2"] = pwm2;
    json["pwm3"] = pwm3;
    json["an0ch"] = an0ch;
    json["an1ch"] = an1ch;
    json["an2ch"] = an2ch;
    json["an3ch"] = an3ch;
    json["servorev"] = servorev;
    json["magxoff"] = magxoff;
    json["magyoff"] = magyoff;
    json["magzoff"] = magzoff;
    json["accxoff"] = accxoff;
    json["accyoff"] = accyoff;
    json["acczoff"] = acczoff;
    json["gyrxoff"] = gyrxoff;
    json["gyryoff"] = gyryoff;
    json["gyrzoff"] = gyrzoff;
    json["buttonpin"] = buttonpin;
    json["ppmoutpin"] = ppmoutpin;
    json["ppminpin"] = ppminpin;
    json["uartrxpin"] = uartrxpin;
    json["uarttxpin"] = uarttxpin;
    json["sbrate"] = sbrate;
    json["uartrxinv"] = uartrxinv;
    json["uarttxinv"] = uarttxinv;
  }

  void loadJSONSettings(DynamicJsonDocument &json) {
    JsonVariant v;
    v = json["rll_min"]; if(!v.isNull()) setRll_Min(v);
    v = json["rll_max"]; if(!v.isNull()) setRll_Max(v);
    v = json["rll_cnt"]; if(!v.isNull()) setRll_Cnt(v);
    v = json["rll_gain"]; if(!v.isNull()) setRll_Gain(v);
    v = json["tlt_min"]; if(!v.isNull()) setTlt_Min(v);
    v = json["tlt_max"]; if(!v.isNull()) setTlt_Max(v);
    v = json["tlt_cnt"]; if(!v.isNull()) setTlt_Cnt(v);
    v = json["tlt_gain"]; if(!v.isNull()) setTlt_Gain(v);
    v = json["pan_min"]; if(!v.isNull()) setPan_Min(v);
    v = json["pan_max"]; if(!v.isNull()) setPan_Max(v);
    v = json["pan_cnt"]; if(!v.isNull()) setPan_Cnt(v);
    v = json["pan_gain"]; if(!v.isNull()) setPan_Gain(v);
    v = json["tltch"]; if(!v.isNull()) setTltCh(v);
    v = json["rllch"]; if(!v.isNull()) setRllCh(v);
    v = json["panch"]; if(!v.isNull()) setPanCh(v);
    v = json["alertch"]; if(!v.isNull()) setAlertCh(v);
    v = json["pwm0"]; if(!v.isNull()) setPwm0(v);
    v = json["pwm1"]; if(!v.isNull()) setPwm1(v);
    v = json["pwm2"]; if(!v.isNull()) setPwm2(v);
    v = json["pwm3"]; if(!v.isNull()) setPwm3(v);
    v = json["an0ch"]; if(!v.isNull()) setAn0Ch(v);
    v = json["an1ch"]; if(!v.isNull()) setAn1Ch(v);
    v = json["an2ch"]; if(!v.isNull()) setAn2Ch(v);
    v = json["an3ch"]; if(!v.isNull()) setAn3Ch(v);
    v = json["servorev"]; if(!v.isNull()) setServoRev(v);
    v = json["magxoff"]; if(!v.isNull()) setMagXOff(v);
    v = json["magyoff"]; if(!v.isNull()) setMagYOff(v);
    v = json["magzoff"]; if(!v.isNull()) setMagZOff(v);
    v = json["accxoff"]; if(!v.isNull()) setAccXOff(v);
    v = json["accyoff"]; if(!v.isNull()) setAccYOff(v);
    v = json["acczoff"]; if(!v.isNull()) setAccZOff(v);
    v = json["gyrxoff"]; if(!v.isNull()) setGyrXOff(v);
    v = json["gyryoff"]; if(!v.isNull()) setGyrYOff(v);
    v = json["gyrzoff"]; if(!v.isNull()) setGyrZOff(v);
    v = json["buttonpin"]; if(!v.isNull()) setButtonPin(v);
    v = json["ppmoutpin"]; if(!v.isNull()) setPpmOutPin(v);
    v = json["ppminpin"]; if(!v.isNull()) setPpmInPin(v);
    v = json["uartrxpin"]; if(!v.isNull()) setUartRxPin(v);
    v = json["uarttxpin"]; if(!v.isNull()) setUartTxPin(v);
    v = json["sbrate"]; if(!v.isNull()) setSbRate(v);
    v = json["uartrxinv"]; if(!v.isNull()) setUartRxInv(v);
    v = json["uarttxinv"]; if(!v.isNull()) setUartTxInv(v);
  }

private:
  //Settings
  uint16_t rll_min = DEF_MIN_PWM; // Roll Minimum
  uint16_t rll_max = DEF_MAX_PWM; // Roll Maximum
  uint16_t rll_cnt = PPM_CENTER; // Roll Center
  uint16_t rll_gain = 5; // Roll Gain
  uint16_t tlt_min = DEF_MIN_PWM; // Tilt Minimum
  uint16_t tlt_max = DEF_MAX_PWM; // Tilt Maximum
  uint16_t tlt_cnt = PPM_CENTER; // Tilt Center
  uint16_t tlt_gain = 5; // Tilt Gain
  uint16_t pan_min = DEF_MIN_PWM; // Pan Minimum
  uint16_t pan_max = DEF_MAX_PWM; // Pan Maximum
  uint16_t pan_cnt = PPM_CENTER; // Pan Center
  uint16_t pan_gain = 5; // Pan Gain
  uint8_t tltch = 0; // Tilt Output Channel
  uint8_t rllch = 0; // Roll Output Channel
  uint8_t panch = 0; // Pan Output Channel
  uint8_t alertch = 0; // Alert Output Channel
  uint8_t pwm0 = 0; // PWM 0 Channel
  uint8_t pwm1 = 0; // PWM 1 Channel
  uint8_t pwm2 = 0; // PWM 2 Channel
  uint8_t pwm3 = 0; // PWM 3 Channel
  uint8_t an0ch = 0; // Analog 0 Channel
  uint8_t an1ch = 0; // Analog 1 Channel
  uint8_t an2ch = 0; // Analog 2 Channel
  uint8_t an3ch = 0; // Analog 3 Channel
  uint8_t servorev = 0; // Servo Reverse (BitMask)
  float magxoff = 0; // Magnetometer X Calibration Offset
  float magyoff = 0; // Magnetometer Y Calibration Offset
  float magzoff = 0; // Magnetometer Z Calibration Offset
  float accxoff = 0; // Accelerometer X Calibration Offset
  float accyoff = 0; // Accelerometer Y Calibration Offset
  float acczoff = 0; // Accelerometer Z Calibration Offset
  float gyrxoff = 0; // Gyrometer X Calibration Offset
  float gyryoff = 0; // Gyrometer Y Calibration Offset
  float gyrzoff = 0; // Gyrometer Z Calibration Offset
  int8_t buttonpin = -1; // Button Pin
  int8_t ppmoutpin = -1; // PPM Output Pin
  int8_t ppminpin = -1; // PPM Input Pin
  int8_t uartrxpin = -1; // UART Receive Pin
  int8_t uarttxpin = -1; // UART Transmit Pin
  uint8_t sbrate = 30; // SBUS Transmit Freqency
  bool uartrxinv = TRUE; // UART Receieve Inverted
  bool uarttxinv = TRUE; // UART Transmit Inverted

  //Setting Arrays
  float magsioff[9]; // Magnetometer Soft Iron Offset Matrix

  //Real Time Data
  float magx; // Raw Sensor Mag X
  float  magy; // Raw Sensor Mag Y
  float  magz; // Raw Sensor Mag Z
  float gyrox; // Raw Sensor Gyro X
  float gyroy; // Raw Sensor Gyro Y
  float gyroz; // Raw Sensor Gyro Z
  float accx; // Raw Sensor Accel X
  float accy; // Raw Sensor Accel Y
  float accz; // Raw Sensor Accel Z
  float off_magx; // Calibrated Mag X
  float off_magy; // Calibrated Mag Y
  float off_magz; // Calibrated Mag Z
  float off_gyrx; // Calibrated Gyro X
  float off_gyry; // Calibrated Gyro Y
  float off_gyrz; // Calibrated Gyro Z
  float off_accx; // Calibrated Accel X
  float off_accy; // Calibrated Accel Y
  float off_accz; // Calibrated Accel Z
  uint16_t tiltout; // Board Tilt Output (us)
  uint16_t rollout; // Board Roll Output (us)
  uint16_t panout; // Board Pan Output (us)
  bool iscal; // Has the board been Calibrated
  bool btcon; // Bluetooth is connected
  uint8_t brdtype; // Board Type (0=Unknown, 1=Nano3Ble 2=Nano33BleSense, 3=Leele)
  bool trpenabled; // Tilt/Roll/Pan Output Enabled

  //Real Time Data Arrays
  uint16_t chout[16]; // Channel Outputs
  uint16_t btch[bt_channels]; // Bluetooth Inputs
  uint16_t ppmch[16]; // PPM Inputs
  uint16_t sbusch[16]; // SBUS Channels
  float quat[4]; // Quaternion Output (Tilt / Roll / Pan)
  uint8_t btaddr[18]; // Local Bluetooth Address
  uint8_t btrmt[18]; // Remote Bluetooth Address
}
