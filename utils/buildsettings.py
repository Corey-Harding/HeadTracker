from array import array
import csv

f = open("../firmware/src/src/basetrackersettings.h","w")
f.write("""\
/*
* This file is part of the Head Tracker distribution (https://github.com/dlktdr/headtracker)
* Copyright (c) 2022 Cliff Blackburn
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**********************************************
 *
 *  !!! THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY !!!
 *
 *  Modify /utils/settings.csv and execute settings.py to generate the FW headers
 *   GUI Header writer - TODO
 *
 ***********************************************/

#pragma once

#include <stdint.h>
#include <string.h>
#include <math.h>

#include "arduinojsonwrp.h"

extern unsigned int encode_base64(unsigned char input[], unsigned int input_length,
                           unsigned char output[]);

class BaseTrackerSettings {
public:
""")

# CSV Column's
coltype = 0
coldata = 1
colname = 2
coldefault = 3
colmin = 4
colmax = 5
coldesc = 6
colfwonevnt = 7
coldivisor = 8
colround = 9

const = list()
data = list()
dataarrays = list()
settings = list()
settingsarrays = list()

with open('settings.csv', newline='') as csvfile:
    setns = csv.reader(csvfile, delimiter=',', quotechar='\"')
    itersetns = iter(setns)
    next(itersetns)
    for row in setns:
        if "const" in row[coldata].lower():
          const.append(row)
        if "setting" in row[coldata].lower():
          if "[" in row[colname]:
            settingsarrays.append(row)
          else:
            settings.append(row)
        if "data" in row[coldata].lower():
          if "[" in row[colname]:
            dataarrays.append(row)
          else:
            data.append(row)

def typeToJson(type) :
  if type == "float":
    return "flt"
  if type == "double":
    return "dbl"
  if type == "char":
    return "chr"
  return type

def typeToC(type) :
  if type == "u8":
    return "uint8_t"
  if type == "s8":
    return "int8_t"
  if type == "u16":
    return "uint16_t"
  if type == "s16":
    return "int16_t"
  if type == "u32":
    return "uint32_t"
  if type == "s32":
    return "int32_t"
  return type

# Write the constants to the file
for row in const:
  f.write("  static constexpr "  + typeToC(row[coltype]) + " " + row[colname] + " = " + row[coldefault] + ";\n")

# Write the Constructor
f.write("\n  BaseTrackerSettings() {\n")
for row in settingsarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arraylength = row[colname][start+1:end]
  name = row[colname][:start].lower()

  # Fill arrays with the default values
  if "char" in row[coltype]:
    f.write("    " + name + "[0] = '\\0';\n")
  else:
    f.write("    for(int i = 0; i < " + arraylength + "; i++) {\n")
    f.write("      " + name + "[i] = " + row[coldefault] + ";\n")
    f.write("    }\n\n")

for row in dataarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arraylength = row[colname][start+1:end]
  name = row[colname][:start].lower()
  f.write("    memset(" + name + ",0,sizeof(" + typeToC(row[coltype]) + ") * " + arraylength + ");\n")

f.write("\n    // Call Virtual Events after initialization\n")
events = set()
for row in settings:
  events.add(row[colfwonevnt])
for row in events:
  if row != "":
    f.write("    " + row + "();\n");
f.write("  }\n\n")

# Make Virtual Events
f.write("  // Virtual Events\n")

for row in events:
  if row != "":
    f.write("  virtual void " + row + "() {};\n")


# Write the get + set functions
f.write("\n")

for row in settings:
  if row[coltype].lower().strip() == "bool":
    txt = """\
  // {desc}
  inline const {dtype}& get{cname}() {{return {name};}}
  void set{cname}({dtype} val={deflt}) {{ {name} = val; }}\n
""".format(cname = row[colname], name = row[colname].lower(), dtype = typeToC(row[coltype]), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc])
  else:
    txt = """\
  // {desc}
  inline const {dtype}& get{cname}() {{return {name};}}
  bool set{cname}({dtype} val={deflt}) {{
    if(val >= {minv} && val <= {maxv}) {{
      {name} = val;
      return true;
    }}
    return false;
  }}\n\n""".format(cname = row[colname], name = row[colname].lower(), dtype = typeToC(row[coltype]), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc])
  f.write(txt)

# Get & Set for the Settings Arrays
for row in settingsarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arraylength = row[colname][start+1:end]
  if row[coltype].lower().strip() != "char":
    txt = """\
  // {desc}
  void get{cname}({dtype} dest[{len}]) {{memcpy(dest, {name}, sizeof({dtype}) * {len});}}
  bool set{cname}(const {dtype} val[{len}]) {{
    bool changed = false;
    for(int i=0; i < {len}; i++) {{
      if({name}[i] >= {minv} && {name}[i] <= {maxv}) {{
        {name}[i] = val[i];
        changed = true;
      }}
    }}
    return changed;
  }}\n\n""".format(cname = row[colname][:start], name = row[colname][:start].lower(), dtype = typeToC(row[coltype].strip()), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc], len = arraylength )
  else:
    txt = """\
  // {desc}
  void get{cname}({dtype}* dest) {{strcpy(dest, {name});}}
  void set{cname}(const char *val) {{
    strncpy({name}, val, {len}+1);
    {name}[{len}] = '\\0';
  }}\n\n""".format(cname = row[colname][:start], name = row[colname][:start].lower(), dtype = typeToC(row[coltype].strip()), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc], len = arraylength )

  f.write(txt)

# Set Functions for the Data Items
for row in data:
  txt = """\
  // {desc}
  void setData{cname}({dtype} val) {{ {name} = val; }}\n
""".format(cname = row[colname], name = row[colname].lower(), dtype = typeToC(row[coltype].strip()), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc])
  f.write(txt)

# Get & Set for the Data Arrays
for row in dataarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arraylength = row[colname][start+1:end]
  if row[coltype].lower().strip() != "char":
    txt = """\
  // {desc}
  void setData{cname}(const {dtype} val[{len}]) {{
    memcpy({name}, val, {len});
  }}\n\n""".format(cname = row[colname][:start], name = row[colname][:start].lower(), dtype = typeToC(row[coltype].strip()), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc], len = arraylength )
  else:
    txt = """\
  // {desc}
  void setData{cname}(const char *val) {{
    strncpy({name}, val, {len}+1);
    {name}[{len}] = '\\0';
  }}\n\n""".format(cname = row[colname][:start], name = row[colname][:start].lower(), dtype = typeToC(row[coltype].strip()), deflt = row[coldefault], minv = row[colmin], maxv = row[colmax], desc = row[coldesc], len = arraylength )

  f.write(txt)

# Write all JSON Settings
f.write("  void setJSONSettings(DynamicJsonDocument &json) {\n")
for row in settings:
  f.write("    json[\"" + row[colname].lower() + "\"] = " + row[colname].lower() + ";\n");
f.write("  }\n")

# Read JSON Settings
f.write("\n  void loadJSONSettings(DynamicJsonDocument &json) {\n    JsonVariant v;\n")
for row in events: # On change call required
  if row != "":
    f.write("    bool ch" + row.lower() + " = false;\n");
for row in settings:
  f.write("    v = json[\"" + row[colname].lower() + "\"]; if(!v.isNull()) {set" + row[colname] + "(v);");
  if row[colfwonevnt] == "":
    f.write("}\n")
  else:
    f.write(" ch" + row[colfwonevnt].lower() + " = true;}\n")
for row in events: # Do the on Change call
  if row != "":
    f.write("    if(ch" + row.lower() + ")\n      " + row + "();\n");
f.write("  }\n")

# All JSON data Items
f.write("\n  void setJSONDataList(DynamicJsonDocument &json)\n  {\n")
f.write("    JsonArray array = json.createNestedArray();\n")
for row in data:
  f.write("    array.add(\""+ row[colname].lower() + "\");\n")
for row in dataarrays:
  start = row[colname].find("[")
  f.write("    array.add(\""+ row[colname][:start].lower() + "\");\n")
f.write("  }\n")

# Choose what items to send
f.write("""\
  // Sets if a data item should be included while in data to GUI
  void setDataItemSend(const char *var, bool enabled)
  {
""")
id = 0
for row in data:
  id += 1
  txt = """\
    if (strcmp(var, \"{name}\") == 0) {{
      enabled == true ? senddatavars |= 1 << {id} : senddatavars &= ~(1 << {id});
      return;
    }}
""".format( name = row[colname].lower(), id = id)
  f.write(txt)
id = 0
for row in dataarrays:
  start = row[colname].find("[")
  id += 1
  txt = """\
    if (strcmp(var, \"{name}\") == 0) {{
      enabled == true ? senddataarray |= 1 << {id} : senddataarray &= ~(1 << {id});
      return;
    }}
""".format( name = row[colname].lower()[:start], id = id)
  f.write(txt)
f.write("  }\n")

# Transmit Data items back to the gui
f.write("\n  void setJSONData(DynamicJsonDocument &json)\n  {\n")
f.write("""\
    // Sends only requested data items
    // Updates only as often as specified, 1 = every cycle
    // Three Decimals is most precision of any data item req as of now.
    // For most items ends up less bytes than base64 encoding everything

    static int counter = 0;
    bool sendit = false;
    char b64array[500];

""")
id = 0
for row in data:
  id += 1
  try:
    round = int(row[colround])
    round = pow(10, round)
  except ValueError:
    round = 1000

  if row[coltype].lower().strip() == "float":
    valtxt = "roundf(((float)" + row[colname].lower() + " * {round})) / {round}".format(round = round)
  else:
    valtxt = row[colname].lower()

  txt = """\
    if (senddatavars & (1 << {id}) && (counter % {div}) == 0)
      json["{vname}"] = {value};
""".format(vname = row[colname].lower(), value=valtxt, div= row[coldivisor], id=id)
  f.write(txt)

id = 0
for row in dataarrays:
  id += 1
  start = row[colname].find("[")
  end = row[colname].find("]")
  arraylength = row[colname][start+1:end]
  txt = """\

    sendit = false;
    if (senddataarray & (1 << {id})) {{
      if ({div} < 0) {{
        if (memcmp(last{name}, {name}, sizeof({name})) != 0)
          sendit = true;
        else if ({div} != -1 && counter % abs({div}) == 0)
          sendit = true;
      }} else {{
        if (counter % {div} == 0)
          sendit = true;
      }}
      if (sendit) {{
        encode_base64((unsigned char *){name}, sizeof({ctype}) * {len}, (unsigned char *)b64array);
        json["6{name}{jtype}"] = b64array;
        memcpy(last{name}, {name}, sizeof({name}));
      }}
    }}
""".format(name = row[colname].lower()[:start], div = row[coldivisor], id=id,ctype=typeToC(row[coltype].strip()), jtype = typeToJson(row[coltype].strip()), len = arraylength)
  f.write(txt)
f.write("""\

    // Used for reduced data divisor
    counter++;
    if (counter > 500) {
      counter = 0;
    }
  }\n\n""")


# Stop All Data Function
f.write("""\
  void stopAllData()
  {
    senddatavars = 0;
    senddataarray = 0;
  }
""")

# Variables
f.write("\nprotected:\n")

f.write("""\
  // Bit map of data to send to GUI, max 64 items
  uint64_t senddatavars;
  uint64_t senddataarray;
""")

f.write("\n  // Settings\n")
for row in settings:
  f.write("  " + typeToC(row[coltype]) + " " + row[colname].lower())
  if row[coldefault] == "":
    f.write (";")
  else:
    f.write (" = " + row[coldefault] + ";")

  f.write(" // " + row[coldesc] + "\n")

f.write("\n  // Setting Arrays\n")
for row in settingsarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arlen = row[colname][start+1:end]
  if row[coltype].lower().strip() == "char":
    try:
      arlen = int(arraylength)
      arlen += 1 # Increment Storage Space For Null
      arlen = str(arlen)
    except ValueError:
      arlen = arraylength
  f.write("  " + typeToC(row[coltype]) + " " + row[colname][:start].lower() + "[" + arlen + "]; // " + row[coldesc] + "\n")

f.write("\n  // Real Time Data\n")
for row in data:
  f.write("  " + typeToC(row[coltype]) + " " + row[colname].lower() + " = 0; // " + row[coldesc] + "\n")

f.write("\n  // Real Time Data Arrays\n")
for row in dataarrays:
  start = row[colname].find("[")
  end = row[colname].find("]")
  arlen = row[colname][start+1:end]
  if row[coltype].lower().strip() == "char":
    try:
      arlen = int(arraylength)
      arlen += 1
      arlen = str(arlen)
    except ValueError:
      arlen = arraylength
  f.write("  " + typeToC(row[coltype]) + " " + row[colname][:start].lower() + "[" + arlen + "]; // " + row[coldesc] + "\n")
  f.write("  " + typeToC(row[coltype]) + " last" + row[colname][:start].lower() + "[" + arlen + "]; // " + row[coldesc] + "\n")

# Close Class
f.write("};\n")

f.close()

print("Gernerated Firmware Settings Base Class")